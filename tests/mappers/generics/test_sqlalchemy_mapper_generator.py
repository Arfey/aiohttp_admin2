from enum import Enum

import sqlalchemy as sa

from aiohttp_admin2.mappers import fields
from aiohttp_admin2.mappers.generics import PostgresMapperGeneric


tbl = sa.Table('tbl', sa.MetaData(),
    sa.Column('id', sa.Integer, primary_key=True),
    sa.Column('title', sa.String(255)),
)


def test_base_generated_mapper_for_sa():
    """
    In this test we check corrected work of auto generator for mapper from
    alchemy table.
    """

    class BookMapper(PostgresMapperGeneric, table=tbl):
        pass

    book = BookMapper({"id": 1, "title": "My test book1"})

    assert len(book.fields) == 2

    assert isinstance(book.fields["id"], fields.IntField)
    assert isinstance(book.fields["title"], fields.StringField)


def test_work_generated_fields_for_sa_together_with_custom():
    """
    In this test we check that we can add custom fields to the generated
    mapper.
    """
    class BookMapper(PostgresMapperGeneric, table=tbl):
        pages = fields.IntField()

    book = BookMapper({"id": 1, "title": "My test book2"})

    assert len(book.fields) == 3
    assert isinstance(book.fields["id"], fields.IntField)
    assert isinstance(book.fields["title"], fields.StringField)
    assert isinstance(book.fields["pages"], fields.IntField)


def test_rewrite_generated_fields_for_sa():
    """
    In this test we check that we can to rewrite autogenerated field in the
    mapper.
    """
    class BookMapper(PostgresMapperGeneric, table=tbl):
        id = fields.StringField()

    book = BookMapper({"id": 1, "title": "My test book3"})

    assert len(book.fields) == 2
    assert isinstance(book.fields["id"], fields.StringField)
    assert isinstance(book.fields["title"], fields.StringField)


def test_corrected_format_of_fields():
    """
    In this test we check that for each sa types we have use appropriate field.
    """
    table = sa.Table('table', sa.MetaData(),
        sa.Column('Integer', sa.Integer, primary_key=True),
        sa.Column('BigInteger', sa.BigInteger),
        sa.Column('SmallInteger', sa.SmallInteger),
        sa.Column('Float', sa.Float),
        sa.Column('Text', sa.Text),
        sa.Column('Boolean', sa.Boolean),
        sa.Column('ARRAY', sa.ARRAY(sa.Integer)),
        sa.Column('DateTime', sa.DateTime),
        sa.Column('Date', sa.Date),
        sa.Column('JSON', sa.JSON),
    )

    class TypesMapper(PostgresMapperGeneric, table=table):
        pass

    mapper = TypesMapper({})

    assert len(mapper.fields) == len(table.c)
    assert isinstance(mapper.fields["Integer"], fields.IntField)
    assert isinstance(mapper.fields["BigInteger"], fields.IntField)
    assert isinstance(mapper.fields["SmallInteger"], fields.SmallIntField)
    assert isinstance(mapper.fields["Text"], fields.StringField)
    assert isinstance(mapper.fields["Boolean"], fields.BooleanField)
    assert isinstance(mapper.fields["ARRAY"], fields.ArrayField)
    assert isinstance(mapper.fields["DateTime"], fields.DateTimeField)
    assert isinstance(mapper.fields["Date"], fields.DateField)
    assert isinstance(mapper.fields["JSON"], fields.JsonField)


def test_default_field_type():
    """
    In this test we check that if admin don't know about received sa type then
    it set default field.
    """
    table = sa.Table('table', sa.MetaData(),
        sa.Column("unknown_object", sa.sql.sqltypes._Binary, primary_key=True),
    )

    # default DEFAULT_FIELD
    class TypesMapper(PostgresMapperGeneric, table=table):
        pass

    mapper = TypesMapper({})
    assert isinstance(mapper.fields["unknown_object"], fields.StringField)

    # redefined DEFAULT_FIELD
    class TypesMapper(PostgresMapperGeneric, table=table):
        DEFAULT_FIELD = fields.IntField

    mapper = TypesMapper({})
    assert isinstance(mapper.fields["unknown_object"], fields.IntField)


def test_that_we_use_length_of_sa_fields_for_generate_validators():
    """
    In current test we check that we use length constraint from sa models for
    text column for generate validations to mapper's fields.
    """
    table = sa.Table('table', sa.MetaData(),
        sa.Column("text", sa.String(5)),
    )

    class LengthMapper(PostgresMapperGeneric, table=table):
        pass

    assert not LengthMapper({"text": "long text"}).is_valid()
    assert LengthMapper({"text": "short"}).is_valid()


def test_required_field():
    """
    In current test we check that we use nullable constraint from sa models
    for generate validators for mapper's fields.
    """
    table = sa.Table('table', sa.MetaData(),
        sa.Column("id", sa.Integer, nullable=False),
    )

    class RequiredMapper(PostgresMapperGeneric, table=table):
        pass

    assert not RequiredMapper({}).is_valid()
    assert RequiredMapper({"id": 1}).is_valid()


def test_required_pk():
    """In this test we check that primary key fields are required in mapper."""
    table = sa.Table('table', sa.MetaData(),
        sa.Column("id", sa.Integer, primary_key=True),
    )

    class PrimaryKeyMapper(PostgresMapperGeneric, table=table):
        pass

    assert not PrimaryKeyMapper({}).is_valid()
    assert PrimaryKeyMapper({"id": 1}).is_valid()

    # but we can to skip validation of primary keys
    assert PrimaryKeyMapper({}).is_valid(skip_primary=True)


def test_nested_array_types():
    """
    Array type exist nested type of inner elements. Here we check that we get
    correct type from sa model and generate appropriate field.
    """
    table = sa.Table('table', sa.MetaData(),
        sa.Column("arr", sa.ARRAY(sa.BigInteger)),
    )

    class ArrayMapper(PostgresMapperGeneric, table=table):
        pass

    assert not ArrayMapper({"arr": "string"}).is_valid()
    assert not ArrayMapper({"arr": ["string", "string", "string"]}).is_valid()
    assert ArrayMapper({"arr": ["1", "2", "3"]}).is_valid()


def test_choices_field():
    """
    In this test we check correct work of choices field for enum column.

        - correct generation from enum
        - rewrite choices
    """

    class SelectEnum(Enum):
        select = 'select'
        unselect = 'unselect'

    tbl2 = sa.Table('tbl2', sa.MetaData(),
        sa.Column('id', sa.Integer, primary_key=True),
        sa.Column('type', sa.Enum(SelectEnum)),
    )

    class SelectMapper(PostgresMapperGeneric, table=tbl2):
        pass

    # correct generation from enum
    assert SelectMapper({}).fields['type'].choices == \
           [('select', 'select'), ('unselect', 'unselect')]

    gender_choices = (
        ('male', "male"),
        ('female', "female"),
    )

    class SelectSecondMapper(PostgresMapperGeneric, table=tbl2):
        type = fields.ChoicesField(
            field_cls=fields.StringField,
            choices=gender_choices,
            default='male'
        )

    # rewrite choices
    assert SelectSecondMapper({}).fields['type'].choices == gender_choices
